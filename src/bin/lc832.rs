struct Solution;

impl Solution {
    /// Flips the image horizontally and then inverts it.
    ///
    /// # Arguments
    ///
    /// * `image` - A 2D vector representing the binary image.
    ///
    /// # Returns
    ///
    /// * A 2D vector representing the flipped and inverted image.
    ///
    /// # Example
    ///
    /// ```
    /// let image = vec![vec![1, 1, 0], vec![1, 0, 1], vec![0, 0, 0]];
    /// let result = Solution::flip_and_invert_image(image);
    /// assert_eq!(result, vec![vec![1, 0, 0], vec![0, 1, 0], vec![1, 1, 1]]);
    /// ```
    pub fn flip_and_invert_image(image: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = image.len();
        let mut image = image;
        
        for i in 0..n {
            image[i].reverse();
            for j in 0..n {
                image[i][j] ^= 1;
            }
        }
        image
    }

}

// generated by copilot

fn main() {
    // Example usage of the flip_and_invert_image function
    let image = vec![vec![1, 1, 0], vec![1, 0, 1], vec![0, 0, 0]];
    let result = Solution::flip_and_invert_image(image);
    println!("{:?}", result);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_flip_and_invert_image() {
        let image = vec![vec![1, 1, 0], vec![1, 0, 1], vec![0, 0, 0]];
        let result = Solution::flip_and_invert_image(image);
        assert_eq!(result, vec![vec![1, 0, 0], vec![0, 1, 0], vec![1, 1, 1]]);
    }

    #[test]
    fn test_flip_and_invert_image_empty() {
        let image: Vec<Vec<i32>> = vec![];
        let _result = Solution::flip_and_invert_image(image);
    }
}

